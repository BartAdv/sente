<!DOCTYPE html PUBLIC ""
    "">
<html><head><meta charset="UTF-8" /><link href="css/default.css" rel="stylesheet" type="text/css" /><script src="js/jquery.min.js" type="text/javascript"></script><script src="js/page_effects.js" type="text/javascript"></script><title>taoensso.sente documentation</title></head><body><div id="header"><h2>Generated by <a href="https://github.com/weavejester/codox">Codox</a></h2><h1><a href="index.html"><span class="project-title"><span class="project-name">Sente</span> <span class="project-version">1.9.0-beta1</span></span></a></h1></div><div class="sidebar primary"><h3 class="no-link"><span class="inner">Project</span></h3><ul class="index-link"><li class="depth-1 "><a href="index.html"><div class="inner">Index</div></a></li></ul><h3 class="no-link"><span class="inner">Namespaces</span></h3><ul><li class="depth-1"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>taoensso</span></div></div></li><li class="depth-2 current"><a href="taoensso.sente.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>sente</span></div></a></li><li class="depth-3 branch"><a href="taoensso.sente.interfaces.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>interfaces</span></div></a></li><li class="depth-3"><div class="no-link"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>packers</span></div></div></li><li class="depth-4"><a href="taoensso.sente.packers.transit.html"><div class="inner"><span class="tree"><span class="top"></span><span class="bottom"></span></span><span>transit</span></div></a></li><li class="depth-3"><a href="taoensso.sente.tests.html"><div class="inner"><span class="tree" style="top: -52px;"><span class="top" style="height: 61px;"></span><span class="bottom"></span></span><span>tests</span></div></a></li></ul></div><div class="sidebar secondary"><h3><a href="#top"><span class="inner">Public Vars</span></a></h3><ul><li class="depth-1"><a href="taoensso.sente.html#var--.3EEdnPacker"><div class="inner"><span>-&gt;EdnPacker</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-as-event"><div class="inner"><span>as-event</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-assert-event"><div class="inner"><span>assert-event</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-client-event-msg.3F"><div class="inner"><span>client-event-msg?</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-debug-mode.3F_"><div class="inner"><span>debug-mode?_</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-event-msg.3F"><div class="inner"><span>event-msg?</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-event.3F"><div class="inner"><span>event?</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-make-channel-socket.21"><div class="inner"><span>make-channel-socket!</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-make-channel-socket-server.21"><div class="inner"><span>make-channel-socket-server!</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-server-event-msg.3F"><div class="inner"><span>server-event-msg?</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-set-logging-level.21"><div class="inner"><span>set-logging-level!</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-start-chsk-router.21"><div class="inner"><span>start-chsk-router!</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-start-chsk-router-loop.21"><div class="inner"><span>start-chsk-router-loop!</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-start-client-chsk-router.21"><div class="inner"><span>start-client-chsk-router!</span></div></a></li><li class="depth-1"><a href="taoensso.sente.html#var-start-server-chsk-router.21"><div class="inner"><span>start-server-chsk-router!</span></div></a></li></ul></div><div class="namespace-docs" id="content"><h1 class="anchor" id="top">taoensso.sente</h1><div class="doc"><pre class="plaintext">Channel sockets for Clojure/Script.

    Protocol  | client&gt;server | client&gt;server ?+ ack/reply | server&gt;user push
  * WebSockets:       ✓              [1]                           ✓
  * Ajax:            [2]              ✓                           [3]

  [1] Emulate with cb-uuid wrapping
  [2] Emulate with dummy-cb wrapping
  [3] Emulate with long-polling

Abbreviations:
  * chsk      - Channel socket (Sente's own pseudo "socket")
  * server-ch - Underlying web server's async channel that implement
                Sente's server channel interface
  * sch       - server-ch alias
  * uid       - User-id. An application-level user identifier used for async
                push. May have semantic meaning (e.g. username, email address),
                may not (e.g. client/random id) - app's discretion.
  * cb        - Callback
  * tout      - Timeout
  * ws        - WebSocket/s
  * pstr      - Packed string. Arbitrary Clojure data serialized as a
                string (e.g. edn) for client&lt;-&gt;server comms
  * udt       - Unix timestamp (datetime long)

Special messages:
  * Callback wrapping: [&lt;clj&gt; &lt;?cb-uuid&gt;] for [1], [2]
  * Callback replies: :chsk/closed, :chsk/timeout, :chsk/error

  * Client-side events:
      [:chsk/handshake [&lt;?uid&gt; &lt;?csrf-token&gt; &lt;?handshake-data&gt; &lt;first-handshake?&gt;]]
      [:chsk/state &lt;new-state-map&gt;]
      [:chsk/recv &lt;ev-as-pushed-from-server&gt;] ; Server&gt;user push
      [:chsk/ws-error &lt;websocket-error&gt;] ; Alpha, subject to change

  * Server-side events:
      [:chsk/bad-package &lt;packed-str&gt;]
      [:chsk/bad-event   &lt;event&gt;]
      [:chsk/uidport-open  &lt;uid&gt;]
      [:chsk/uidport-close &lt;uid&gt;]

Notable implementation details:
  * core.async is used liberally where brute-force core.async allows for
    significant implementation simplifications. We lean on core.async's
    efficiency here.
  * For WebSocket fallback we use long-polling rather than HTTP 1.1 streaming
    (chunked transfer encoding). Http-kit _does_ support chunked transfer
    encoding but a small minority of browsers &amp;/or proxies do not. Instead of
    implementing all 3 modes (WebSockets, streaming, long-polling) - it seemed
    reasonable to focus on the two extremes (performance + compatibility).
    In any case client support for WebSockets is growing rapidly so fallback
    modes will become increasingly irrelevant while the extra simplicity will
    continue to pay dividends.

General-use notes:
  * Single HTTP req+session persists over entire chsk session but cannot
    modify sessions! Use standard a/sync HTTP Ring req/resp for logins, etc.
  * Easy to wrap standard HTTP Ring resps for transport over chsks. Prefer
    this approach to modifying handlers (better portability).</pre></div><div class="public anchor" id="var--.3EEdnPacker"><h3>-&gt;EdnPacker</h3><div class="usage"><code>(-&gt;EdnPacker)</code></div><div class="doc"><pre class="plaintext">Positional factory function for class taoensso.sente.EdnPacker.
</pre></div><div class="src-link"><a href="https://github.com/ptaoussanis/sente/blob/master/src/taoensso/sente.cljx#L211">view source</a></div></div><div class="public anchor" id="var-as-event"><h3>as-event</h3><div class="usage"><code>(as-event x)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="https://github.com/ptaoussanis/sente/blob/master/src/taoensso/sente.cljx#L108">view source</a></div></div><div class="public anchor" id="var-assert-event"><h3>assert-event</h3><div class="usage"><code>(assert-event x)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="https://github.com/ptaoussanis/sente/blob/master/src/taoensso/sente.cljx#L110">view source</a></div></div><div class="public anchor" id="var-client-event-msg.3F"><h3>client-event-msg?</h3><div class="usage"><code>(client-event-msg? x)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="https://github.com/ptaoussanis/sente/blob/master/src/taoensso/sente.cljx#L123">view source</a></div></div><div class="public anchor" id="var-debug-mode.3F_"><h3>debug-mode?_</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="https://github.com/ptaoussanis/sente/blob/master/src/taoensso/sente.cljx#L90">view source</a></div></div><div class="public anchor" id="var-event-msg.3F"><h3>event-msg?</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="https://github.com/ptaoussanis/sente/blob/master/src/taoensso/sente.cljx#L1440">view source</a></div></div><div class="public anchor" id="var-event.3F"><h3>event?</h3><div class="usage"><code>(event? x)</code></div><div class="doc"><pre class="plaintext">Valid [ev-id ?ev-data] form?
</pre></div><div class="src-link"><a href="https://github.com/ptaoussanis/sente/blob/master/src/taoensso/sente.cljx#L106">view source</a></div></div><div class="public anchor" id="var-make-channel-socket.21"><h3>make-channel-socket!</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="https://github.com/ptaoussanis/sente/blob/master/src/taoensso/sente.cljx#L1442">view source</a></div></div><div class="public anchor" id="var-make-channel-socket-server.21"><h3>make-channel-socket-server!</h3><div class="usage"><code>(make-channel-socket-server! web-server-adapter &amp; [{:keys [recv-buf-or-n ws-kalive-ms lp-timeout-ms send-buf-ms-ajax send-buf-ms-ws user-id-fn csrf-token-fn handshake-data-fn packer], :or {ws-kalive-ms (enc/ms :secs 25), send-buf-ms-ws 30, lp-timeout-ms (enc/ms :secs 20), csrf-token-fn (fn [ring-req] (or (get-in ring-req [:session :csrf-token]) (get-in ring-req [:session :ring.middleware.anti-forgery/anti-forgery-token]) (get-in ring-req [:session "__anti-forgery-token"]))), packer :edn, send-buf-ms-ajax 100, handshake-data-fn (fn [ring-req] nil), user-id-fn (fn [ring-req] (get-in ring-req [:session :uid])), recv-buf-or-n (async/sliding-buffer 1000)}}])</code></div><div class="doc"><pre class="plaintext">Takes a web server adapter[1] and returns a map with keys:
  :ch-recv ; core.async channel to receive `event-msg`s (internal or from clients).
  :send-fn ; (fn [user-id ev] for server&gt;user push.
  :ajax-post-fn                ; (fn [ring-req]) for Ring CSRF-POST + chsk URL.
  :ajax-get-or-ws-handshake-fn ; (fn [ring-req]) for Ring GET + chsk URL.
  :connected-uids ; Watchable, read-only (atom {:ws #{_} :ajax #{_} :any #{_}}).

Common options:
  :user-id-fn        ; (fn [ring-req]) -&gt; unique user-id for server&gt;user push.
  :csrf-token-fn     ; (fn [ring-req]) -&gt; CSRF token for Ajax POSTs.
  :handshake-data-fn ; (fn [ring-req]) -&gt; arb user data to append to handshake evs.
  :ws-kalive-ms      ; Ping to keep a WebSocket conn alive if no activity
                     ; w/in given msecs.
  :lp-timeout-ms     ; Timeout (repoll) long-polling Ajax conns after given msecs.
  :send-buf-ms-ajax  ; [2]
  :send-buf-ms-ws    ; [2]
  :packer            ; :edn (default), or an IPacker implementation.

[1] e.g. `taoensso.sente.server-adapters.http-kit/http-kit-adapter` or
         `taoensso.sente.server-adapters.immutant/immutant-adapter`.
    You must have the necessary web-server dependency in your project.clj and
    the necessary entry in your namespace's `ns` form.

[2] Optimization to allow transparent batching of rapidly-triggered
    server&gt;user pushes. This is esp. important for Ajax clients which use a
    (slow) reconnecting poller. Actual event dispatch may occur &lt;= given ms
    after send call (larger values =&gt; larger batch windows).</pre></div><div class="src-link"><a href="https://github.com/ptaoussanis/sente/blob/master/src/taoensso/sente.cljx#L243">view source</a></div></div><div class="public anchor" id="var-server-event-msg.3F"><h3>server-event-msg?</h3><div class="usage"><code>(server-event-msg? x)</code></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="https://github.com/ptaoussanis/sente/blob/master/src/taoensso/sente.cljx#L134">view source</a></div></div><div class="public anchor" id="var-set-logging-level.21"><h3>set-logging-level!</h3><div class="usage"></div><div class="doc"><pre class="plaintext">DEPRECATED. Please use `timbre/set-level!` instead
</pre></div><div class="src-link"><a href="https://github.com/ptaoussanis/sente/blob/master/src/taoensso/sente.cljx#L1468">view source</a></div></div><div class="public anchor" id="var-start-chsk-router.21"><h3>start-chsk-router!</h3><div class="usage"></div><div class="doc"><pre class="plaintext"></pre></div><div class="src-link"><a href="https://github.com/ptaoussanis/sente/blob/master/src/taoensso/sente.cljx#L1446">view source</a></div></div><div class="public anchor" id="var-start-chsk-router-loop.21"><h3>start-chsk-router-loop!</h3><div class="usage"><code>(start-chsk-router-loop! event-msg-handler ch-recv)</code></div><div class="doc"><pre class="plaintext">DEPRECATED: Please use `start-chsk-router!` instead
</pre></div><div class="src-link"><a href="https://github.com/ptaoussanis/sente/blob/master/src/taoensso/sente.cljx#L1453">view source</a></div></div><div class="public anchor" id="var-start-client-chsk-router.21"><h3>start-client-chsk-router!</h3><div class="usage"><code>(start-client-chsk-router! ch-recv event-msg-handler &amp; [{:as opts, :keys [trace-evs? error-handler]}])</code></div><div class="doc"><pre class="plaintext">Creates a go-loop to call `(event-msg-handler &lt;client-event-msg&gt;)` and
log any errors. Returns a `(fn stop! [])`.

For performance, you'll likely want your `event-msg-handler` fn to be
non-blocking (at least for slow handling operations). Clojure offers
a rich variety of tools here including futures, agents, core.async,
etc.

Advanced users may also prefer to write their own loop against `ch-recv`.</pre></div><div class="src-link"><a href="https://github.com/ptaoussanis/sente/blob/master/src/taoensso/sente.cljx#L1425">view source</a></div></div><div class="public anchor" id="var-start-server-chsk-router.21"><h3>start-server-chsk-router!</h3><div class="usage"><code>(start-server-chsk-router! ch-recv event-msg-handler &amp; [{:as opts, :keys [trace-evs? error-handler]}])</code></div><div class="doc"><pre class="plaintext">Creates a go-loop to call `(event-msg-handler &lt;server-event-msg&gt;)` and
log any errors. Returns a `(fn stop! [])`.

For performance, you'll likely want your `event-msg-handler` fn to be
non-blocking (at least for slow handling operations). Clojure offers
a rich variety of tools here including futures, agents, core.async,
etc.

Advanced users may also prefer to write their own loop against `ch-recv`.</pre></div><div class="src-link"><a href="https://github.com/ptaoussanis/sente/blob/master/src/taoensso/sente.cljx#L1412">view source</a></div></div></div></body></html>